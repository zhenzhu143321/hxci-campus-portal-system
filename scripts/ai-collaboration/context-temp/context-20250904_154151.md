# AI协作代码上下文报告

生成时间: 2025-09-04 15:41:51
项目: 哈尔滨信息工程学院校园门户系统
技术栈: Spring Boot 3.4.5 + Vue 3

## 📦 收集的文件 (1个)

### 文件: ../../yudao-boot-mini/yudao-mock-school-api/src/main/java/cn/iocoder/yudao/mock/school/controller/MockAuthController.java

```java
package cn.iocoder.yudao.mock.school.controller;

import cn.iocoder.yudao.mock.school.dto.*;
import cn.iocoder.yudao.mock.school.service.MockSchoolUserService;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.validation.annotation.Validated;
import org.springframework.web.bind.annotation.*;

import jakarta.validation.Valid;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

/**
 * Mock School 认证控制器
 * 提供用户token验证和权限查询接口
 * 
 * @author Claude
 */
@RestController
@RequestMapping("/mock-school-api/auth")
@Validated
public class MockAuthController {

    private static final Logger log = LoggerFactory.getLogger(MockAuthController.class);

    @Autowired
    private MockSchoolUserService userService;

    /**
     * 用户认证接口（支持用户名密码登录和工号+姓名+密码登录）
     * POST /mock-school-api/auth/authenticate
     */
    @PostMapping("/authenticate")
    public MockApiResponse<UserInfo> authenticate(@RequestBody AuthenticateRequest request) {
        log.info("收到用户认证请求: employeeId={}, name={}, username={}", 
                request.getEmployeeId(), request.getName(), request.getUsername());
        
        try {
            // 手动验证密码
            if (request.getPassword() == null || request.getPassword().trim().isEmpty()) {
                return MockApiResponse.badRequest("密码不能为空");
            }
            
            UserInfo userInfo = null;
            
            // 优先使用工号+姓名+密码登录方式（新方式）
            if (request.getEmployeeId() != null && !request.getEmployeeId().trim().isEmpty() &&
                request.getName() != null && !request.getName().trim().isEmpty()) {
                
                log.info("使用工号+姓名+密码认证方式: employeeId={}, name={}", 
                        request.getEmployeeId(), request.getName());
                userInfo = userService.authenticateUserByEmployeeId(
                        request.getEmployeeId(), request.getName(), request.getPassword());
            } 
            // 向后兼容：使用用户名密码登录方式（旧方式）
            else if (request.getUsername() != null && !request.getUsername().trim().isEmpty()) {
                
                log.info("使用用户名+密码认证方式: username={}", request.getUsername());
                userInfo = userService.authenticateUser(request.getUsername(), request.getPassword());
            }
            else {
                log.warn("认证参数不完整：缺少必要的登录信息");
                return MockApiResponse.badRequest("请提供工号+姓名+密码或用户名+密码进行登录");
            }
            
            if (userInfo == null) {
                return MockApiResponse.unauthorized("用户名或密码错误");
            }
            
            log.info("用户认证成功: 用户={}, 角色={}", userInfo.getUsername(), userInfo.getRoleName());
            return MockApiResponse.success(userInfo, "用户认证成功");
            
        } catch (Exception e) {
            log.error("用户认证异常", e);
            return MockApiResponse.serverError("用户认证服务异常: " + e.getMessage());
        }
    }

    /**
     * 🛡️ P1.2安全修复：Token脱敏工具方法
     * 防止完整Token在日志中泄露
     */
    private String maskToken(String token) {
        if (token == null || token.length() < 20) {
            return "***INVALID_TOKEN***";
        }
        return token.substring(0, 10) + "..." + token.substring(token.length() - 6);
    }

    /**
     * Token验证接口
     * POST /mock-school-api/auth/verify
     */
    @PostMapping("/verify")
    public MockApiResponse<UserInfo> verifyToken(@Valid @RequestBody TokenVerifyRequest request) {
        log.info("🔍 [TOKEN_VERIFY_V2] P1.2强化版本：收到token验证请求");
        log.info("🛡️ [TOKEN_VERIFY_V2] Token脱敏: {}", maskToken(request.getToken()));
        
        try {
            UserInfo userInfo = userService.verifyToken(request.getToken());
            
            if (userInfo == null) {
                return MockApiResponse.unauthorized("Token无效或已过期");
            }
            
            log.info("✅ [TOKEN_VERIFY_V2] P1.2强化Token验证成功: 用户={}, 角色={}", 
                    userInfo.getUsername(), userInfo.getRoleName());
            return MockApiResponse.success(userInfo, "Token验证成功");
            
        } catch (Exception e) {
            log.error("❌ [TOKEN_VERIFY_V2] Token验证异常", e);
            return MockApiResponse.serverError("Token验证服务异常: " + e.getMessage());
        }
    }

    // 🚫 [REFACTORED] 权限相关接口已移除 - 职责转移到主通知服务
    // 原权限查询和验证接口已删除，现在由主服务统一处理权限逻辑

    /**
     * 刷新用户Token
     * POST /mock-school-api/auth/refresh/{userId}
     */
    @PostMapping("/refresh/{userId}")
    public MockApiResponse<String> refreshToken(@PathVariable String userId) {
        log.info("刷新用户Token: {}", userId);
        
        try {
            String newToken = userService.refreshUserToken(userId);
            
            if (newToken == null) {
                return MockApiResponse.badRequest("用户不存在");
            }
            
            return MockApiResponse.success(newToken, "Token刷新成功");
            
        } catch (Exception e) {
            log.error("Token刷新异常", e);
            return MockApiResponse.serverError("Token刷新异常: " + e.getMessage());
        }
    }

    // 🚫 [REFACTORED] 移除权限验证接口 - 职责转移到主通知服务
    // 原 verify-permission 接口已删除，权限验证现在由主服务负责
    
    /**
     * 🆕 获取用户基础信息（用于主服务权限查询）
     * POST /mock-school-api/auth/user-info
     */
    @PostMapping("/user-info")
    public MockApiResponse<Map<String, Object>> getUserInfo(
            @RequestHeader("Authorization") String authHeader) {
        
        log.info("👤 [USER_INFO] 收到用户信息查询请求");
        
        try {
            // 提取Bearer Token
            String token = authHeader;
            if (authHeader != null && authHeader.startsWith("Bearer ")) {
                token = authHeader.substring(7);
            }
            
            // 通过token验证用户身份
            UserInfo userInfo = userService.verifyToken(token);
            if (userInfo == null) {
                return MockApiResponse.unauthorized("Token无效或已过期");
            }
            
            // 返回用户基础信息（不含权限验证逻辑）
            Map<String, Object> responseData = new HashMap<>();
            responseData.put("employeeId", userInfo.getEmployeeId());
            responseData.put("username", userInfo.getUsername());
            responseData.put("realName", userInfo.getRealName());
            responseData.put("roleCode", userInfo.getRoleCode());
            responseData.put("roleName", userInfo.getRoleName());
            responseData.put("userType", userInfo.getUserType());
            responseData.put("departmentId", userInfo.getDepartmentId());
            responseData.put("departmentName", userInfo.getDepartmentName());
            responseData.put("gradeId", userInfo.getGradeId());
            responseData.put("classId", userInfo.getClassId());
            
            log.info("✅ [USER_INFO] 用户信息查询成功: user={}, role={}", 
                    userInfo.getEmployeeId(), userInfo.getRoleCode());
            
            return MockApiResponse.success(responseData, "用户信息查询成功");
            
        } catch (Exception e) {
            log.error("❌ [USER_INFO] 用户信息查询异常", e);
            return MockApiResponse.serverError("用户信息查询异常: " + e.getMessage());
        }
    }

    /**
     * 🆕 学校登录接口（双Token认证）
     * POST /mock-school-api/auth/school-login
     * 
     * 实现完整的双Token认证流程：
     * 1. 调用学校API验证用户身份
     * 2. 保存Basic Token到Redis+数据库
     * 3. 生成JWT Token用于系统访问
     * 4. 返回双Token结果
     */
    @PostMapping("/school-login")
    public MockApiResponse<SchoolLoginResult> loginViaSchool(@Valid @RequestBody SchoolLoginRequest request) {
        log.info("🏫 [SCHOOL_LOGIN] 收到学校登录请求: employeeId={}, name={}, useRealApi={}", 
                request.getEmployeeId(), request.getName(), request.getUseRealSchoolApi());
        
        try {
            // 调用Service层的流程编排器方法
            SchoolLoginResult result = userService.processSchoolAuthentication(request);
            
            if (result == null || result.getJwtToken() == null) {
                return MockApiResponse.badRequest("学校登录失败：认证结果为空");
            }
            
            log.info("🎉 [SCHOOL_LOGIN] 学校登录成功: employeeId={}, role={}, mode={}", 
                    result.getUserInfo().getEmployeeId(), 
                    result.getUserInfo().getRoleCode(), 
                    result.getAuthMode());
            
            return MockApiResponse.success(result, "学校认证成功，双Token生成完成");
            
        } catch (SecurityException e) {
            log.error("🚨 [SCHOOL_LOGIN] 安全验证失败: {}", e.getMessage());
            return MockApiResponse.unauthorized("学校登录失败: " + e.getMessage());
            
        } catch (Exception e) {
            log.error("💥 [SCHOOL_LOGIN] 学校登录异常", e);
            return MockApiResponse.serverError("学校登录服务异常: " + e.getMessage());
        }
    }

    /**
     * 🆕 获取Basic Token（后端服务间调用）
     * GET /mock-school-api/auth/basic-token/{userId}
     * 
     * 用于其他后端服务获取用户的Basic Token来调用学校API
     */
    @GetMapping("/basic-token/{userId}")
    public MockApiResponse<String> getBasicToken(@PathVariable String userId,
            @RequestHeader("Authorization") String authHeader) {
        log.info("🔍 [BASIC_TOKEN] 获取Basic Token请求: userId={}", userId);
        
        try {
            // 验证请求者身份（简化实现，实际应该验证服务间调用权限）
            String token = authHeader;
            if (authHeader != null && authHeader.startsWith("Bearer ")) {
                token = authHeader.substring(7);
            }
            
            UserInfo requestUser = userService.verifyToken(token);
            if (requestUser == null) {
                return MockApiResponse.unauthorized("请求者Token无效");
            }
            
            // 这里应该调用SchoolTokenService获取Basic Token
            // 简化实现：返回成功但提示功能开发中
            log.info("✅ [BASIC_TOKEN] Basic Token获取请求处理完成（功能开发中）");
            return MockApiResponse.success(null, "Basic Token获取功能开发中");
            
        } catch (Exception e) {
            log.error("❌ [BASIC_TOKEN] Basic Token获取异常", e);
            return MockApiResponse.serverError("Basic Token获取异常: " + e.getMessage());
        }
    }

    /**
     * 🆕 刷新Basic Token
     * POST /mock-school-api/auth/refresh-basic-token/{userId}
     * 
     * 当Basic Token过期时调用学校API刷新
     */
    @PostMapping("/refresh-basic-token/{userId}")
    public MockApiResponse<String> refreshBasicToken(@PathVariable String userId,
            @RequestHeader("Authorization") String authHeader) {
        log.info("🔄 [REFRESH_BASIC_TOKEN] 刷新Basic Token请求: userId={}", userId);
        
        try {
            // 验证请求者身份
            String token = authHeader;
            if (authHeader != null && authHeader.startsWith("Bearer ")) {
                token = authHeader.substring(7);
            }
            
            UserInfo requestUser = userService.verifyToken(token);
            if (requestUser == null) {
                return MockApiResponse.unauthorized("请求者Token无效");
            }
            
            // 这里应该调用SchoolTokenService刷新Token
            // 简化实现：返回成功但提示功能开发中
            log.info("✅ [REFRESH_BASIC_TOKEN] Basic Token刷新请求处理完成（功能开发中）");
            return MockApiResponse.success(null, "Basic Token刷新功能开发中");
            
        } catch (Exception e) {
            log.error("❌ [REFRESH_BASIC_TOKEN] Basic Token刷新异常", e);
            return MockApiResponse.serverError("Basic Token刷新异常: " + e.getMessage());
        }
    }

    /**
     * 🆕 学校API集成状态检查
     * GET /mock-school-api/auth/school-integration-status
     */
    @GetMapping("/school-integration-status")
    public MockApiResponse<Map<String, Object>> getSchoolIntegrationStatus() {
        log.info("📊 [INTEGRATION_STATUS] 检查学校API集成状态");
        
        try {
            Map<String, Object> status = new HashMap<>();
            status.put("timestamp", System.currentTimeMillis());
            
            // 这里应该检查SchoolApiClient的服务状态
            // 简化实现
            status.put("schoolApiAvailable", true);
            status.put("mockMode", true);
            status.put("realApiEndpoint", "https://work.greathiit.com/api/user/loginWai");
            status.put("supportedFeatures", List.of("authentication", "token_refresh", "user_mapping"));
            
            return MockApiResponse.success(status, "学校API集成状态检查完成");
            
        } catch (Exception e) {
            log.error("❌ [INTEGRATION_STATUS] 集成状态检查异常", e);
            return MockApiResponse.serverError("集成状态检查异常: " + e.getMessage());
        }
    }

    /**
     * 健康检查接口
     * GET /mock-school-api/auth/health
     */
    @GetMapping("/health")
    public MockApiResponse<String> health() {
        return MockApiResponse.success("OK", "Mock School API认证服务正常运行");
    }
}
```

---

