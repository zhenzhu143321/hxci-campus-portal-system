<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Phase6 è¡¥å……éªŒè¯æµ‹è¯• - æ™ºèƒ½é€šçŸ¥ç³»ç»Ÿ</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #2c3e50 0%, #34495e 100%);
            min-height: 100vh;
            color: #333;
            padding: 20px;
        }

        .verification-container {
            max-width: 1200px;
            margin: 0 auto;
            background: rgba(255, 255, 255, 0.95);
            border-radius: 15px;
            padding: 30px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.1);
        }

        .header {
            text-align: center;
            margin-bottom: 40px;
        }

        .header h1 {
            font-size: 2.5rem;
            color: #2c3e50;
            margin-bottom: 10px;
        }

        .header .subtitle {
            font-size: 1.2rem;
            color: #7f8c8d;
        }

        .verification-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 30px;
            margin-bottom: 40px;
        }

        .verification-card {
            background: white;
            border-radius: 12px;
            padding: 25px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.08);
            border-left: 5px solid #3498db;
            transition: all 0.3s ease;
        }

        .verification-card:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(0,0,0,0.12);
        }

        .verification-card.success {
            border-left-color: #27ae60;
            background: linear-gradient(135deg, #f8fff9 0%, #e8f5e8 100%);
        }

        .verification-card.warning {
            border-left-color: #f39c12;
            background: linear-gradient(135deg, #fffdf8 0%, #fef9e7 100%);
        }

        .verification-card.error {
            border-left-color: #e74c3c;
            background: linear-gradient(135deg, #fff8f8 0%, #fde8e8 100%);
        }

        .card-header {
            display: flex;
            align-items: center;
            margin-bottom: 15px;
        }

        .card-icon {
            font-size: 2rem;
            margin-right: 15px;
        }

        .card-title {
            font-size: 1.3rem;
            font-weight: 600;
            color: #2c3e50;
        }

        .card-content {
            margin-bottom: 20px;
        }

        .verification-item {
            display: flex;
            align-items: center;
            margin: 10px 0;
            padding: 8px 0;
            border-bottom: 1px solid #ecf0f1;
        }

        .verification-item:last-child {
            border-bottom: none;
        }

        .status-icon {
            margin-right: 10px;
            font-weight: bold;
        }

        .status-text {
            flex: 1;
            font-size: 0.95rem;
        }

        .test-button {
            background: #3498db;
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 0.9rem;
            font-weight: 500;
            transition: all 0.3s ease;
            margin: 5px;
        }

        .test-button:hover {
            background: #2980b9;
            transform: translateY(-1px);
        }

        .test-button:disabled {
            background: #bdc3c7;
            cursor: not-allowed;
            transform: none;
        }

        .progress-bar {
            width: 100%;
            height: 8px;
            background: #ecf0f1;
            border-radius: 4px;
            overflow: hidden;
            margin: 20px 0;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #3498db, #2ecc71);
            border-radius: 4px;
            transition: width 0.3s ease;
        }

        .log-container {
            background: #2c3e50;
            color: white;
            border-radius: 8px;
            padding: 20px;
            margin-top: 30px;
            max-height: 400px;
            overflow-y: auto;
            font-family: 'Courier New', monospace;
            font-size: 0.9rem;
        }

        .log-entry {
            margin: 5px 0;
            opacity: 0;
            animation: fadeIn 0.3s ease forwards;
        }

        @keyframes fadeIn {
            to { opacity: 1; }
        }

        .log-entry.info { color: #74b9ff; }
        .log-entry.success { color: #00b894; }
        .log-entry.warning { color: #fdcb6e; }
        .log-entry.error { color: #e17055; }

        .summary-section {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border-radius: 15px;
            padding: 30px;
            margin-top: 40px;
            text-align: center;
        }

        .summary-stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            gap: 20px;
            margin-top: 20px;
        }

        .stat-item {
            background: rgba(255, 255, 255, 0.2);
            border-radius: 10px;
            padding: 15px;
            backdrop-filter: blur(10px);
        }

        .stat-value {
            font-size: 2rem;
            font-weight: bold;
            margin-bottom: 5px;
        }

        .stat-label {
            font-size: 0.9rem;
            opacity: 0.9;
        }

        /* å“åº”å¼è®¾è®¡ */
        @media (max-width: 768px) {
            .verification-container {
                padding: 20px;
                margin: 10px;
            }
            
            .verification-grid {
                grid-template-columns: 1fr;
                gap: 20px;
            }
            
            .header h1 {
                font-size: 2rem;
            }
            
            .summary-stats {
                grid-template-columns: repeat(2, 1fr);
            }
        }

        @media (max-width: 480px) {
            .card-header {
                flex-direction: column;
                text-align: center;
            }
            
            .card-icon {
                margin-right: 0;
                margin-bottom: 10px;
            }
        }
    </style>
</head>
<body>
    <div class="verification-container">
        <div class="header">
            <h1>ğŸ” Phase6 è¡¥å……éªŒè¯æµ‹è¯•</h1>
            <div class="subtitle">å®Œæ•´éªŒè¯è¾¹ç•Œæµ‹è¯•ã€æ€§èƒ½ã€å…¼å®¹æ€§å’Œç”¨æˆ·ä½“éªŒ</div>
        </div>

        <div class="progress-bar">
            <div class="progress-fill" id="overallProgress" style="width: 80%;"></div>
        </div>

        <div class="verification-grid">
            <!-- è¾¹ç•Œæµ‹è¯•éªŒè¯ -->
            <div class="verification-card" id="boundaryCard">
                <div class="card-header">
                    <div class="card-icon">ğŸš§</div>
                    <div class="card-title">è¾¹ç•Œæµ‹è¯•éªŒè¯</div>
                </div>
                <div class="card-content">
                    <div class="verification-item">
                        <span class="status-icon" id="boundaryPermission">â³</span>
                        <span class="status-text">æƒé™è¾¹ç•Œæµ‹è¯•</span>
                    </div>
                    <div class="verification-item">
                        <span class="status-icon" id="boundaryException">â³</span>
                        <span class="status-text">å¼‚å¸¸å¤„ç†æµ‹è¯•</span>
                    </div>
                    <div class="verification-item">
                        <span class="status-icon" id="boundaryEdge">â³</span>
                        <span class="status-text">è¾¹ç•Œæ¡ä»¶æµ‹è¯•</span>
                    </div>
                </div>
                <button class="test-button" onclick="runBoundaryTests()">å¼€å§‹è¾¹ç•Œæµ‹è¯•</button>
            </div>

            <!-- æ€§èƒ½éªŒè¯ -->
            <div class="verification-card" id="performanceCard">
                <div class="card-header">
                    <div class="card-icon">âš¡</div>
                    <div class="card-title">æ€§èƒ½éªŒè¯</div>
                </div>
                <div class="card-content">
                    <div class="verification-item">
                        <span class="status-icon" id="performanceLoad">â³</span>
                        <span class="status-text">é¡µé¢åŠ è½½æ€§èƒ½</span>
                    </div>
                    <div class="verification-item">
                        <span class="status-icon" id="performanceAPI">â³</span>
                        <span class="status-text">APIå“åº”æ€§èƒ½</span>
                    </div>
                    <div class="verification-item">
                        <span class="status-icon" id="performanceConcurrency">â³</span>
                        <span class="status-text">å¹¶å‘å¤„ç†èƒ½åŠ›</span>
                    </div>
                </div>
                <button class="test-button" onclick="runPerformanceTests()">å¼€å§‹æ€§èƒ½æµ‹è¯•</button>
            </div>

            <!-- å…¼å®¹æ€§éªŒè¯ -->
            <div class="verification-card" id="compatibilityCard">
                <div class="card-header">
                    <div class="card-icon">ğŸŒ</div>
                    <div class="card-title">å…¼å®¹æ€§éªŒè¯</div>
                </div>
                <div class="card-content">
                    <div class="verification-item">
                        <span class="status-icon" id="compatibilityBrowser">â³</span>
                        <span class="status-text">æµè§ˆå™¨å…¼å®¹æ€§</span>
                    </div>
                    <div class="verification-item">
                        <span class="status-icon" id="compatibilityDevice">â³</span>
                        <span class="status-text">è®¾å¤‡å…¼å®¹æ€§</span>
                    </div>
                    <div class="verification-item">
                        <span class="status-icon" id="compatibilityFeature">â³</span>
                        <span class="status-text">åŠŸèƒ½ç‰¹æ€§å…¼å®¹</span>
                    </div>
                </div>
                <button class="test-button" onclick="runCompatibilityTests()">å¼€å§‹å…¼å®¹æ€§æµ‹è¯•</button>
            </div>

            <!-- ç”¨æˆ·ä½“éªŒéªŒè¯ -->
            <div class="verification-card" id="uxCard">
                <div class="card-header">
                    <div class="card-icon">ğŸ‘¥</div>
                    <div class="card-title">ç”¨æˆ·ä½“éªŒéªŒè¯</div>
                </div>
                <div class="card-content">
                    <div class="verification-item">
                        <span class="status-icon" id="uxWorkflow">â³</span>
                        <span class="status-text">å®Œæ•´æ“ä½œæµç¨‹</span>
                    </div>
                    <div class="verification-item">
                        <span class="status-icon" id="uxAccessibility">â³</span>
                        <span class="status-text">æ— éšœç¢è®¿é—®</span>
                    </div>
                    <div class="verification-item">
                        <span class="status-icon" id="uxResponsive">â³</span>
                        <span class="status-text">å“åº”å¼ä½“éªŒ</span>
                    </div>
                </div>
                <button class="test-button" onclick="runUXTests()">å¼€å§‹ç”¨æˆ·ä½“éªŒæµ‹è¯•</button>
            </div>
        </div>

        <!-- ä¸€é”®å…¨é¢éªŒè¯ -->
        <div style="text-align: center; margin: 30px 0;">
            <button class="test-button" 
                    style="background: #e74c3c; font-size: 1.1rem; padding: 15px 30px;"
                    onclick="runAllVerificationTests()">
                ğŸš€ å¯åŠ¨å…¨é¢éªŒè¯æµ‹è¯•
            </button>
        </div>

        <!-- æ—¥å¿—å®¹å™¨ -->
        <div class="log-container" id="logContainer">
            <div class="log-entry info">ğŸ’« Phase6 è¡¥å……éªŒè¯ç³»ç»Ÿå·²å°±ç»ªï¼Œç­‰å¾…æµ‹è¯•æŒ‡ä»¤...</div>
        </div>

        <!-- æ€»ç»“éƒ¨åˆ† -->
        <div class="summary-section" id="summarySection" style="display: none;">
            <h2>ğŸ“Š éªŒè¯æµ‹è¯•æ€»ç»“æŠ¥å‘Š</h2>
            <div class="summary-stats">
                <div class="stat-item">
                    <div class="stat-value" id="totalTests">0</div>
                    <div class="stat-label">æ€»æµ‹è¯•é¡¹</div>
                </div>
                <div class="stat-item">
                    <div class="stat-value" id="passedTests">0</div>
                    <div class="stat-label">é€šè¿‡é¡¹</div>
                </div>
                <div class="stat-item">
                    <div class="stat-value" id="failedTests">0</div>
                    <div class="stat-label">å¤±è´¥é¡¹</div>
                </div>
                <div class="stat-item">
                    <div class="stat-value" id="coveragePercent">0%</div>
                    <div class="stat-label">è¦†ç›–ç‡</div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // å…¨å±€éªŒè¯çŠ¶æ€
        let verificationStats = {
            boundary: { total: 3, passed: 0, failed: 0 },
            performance: { total: 3, passed: 0, failed: 0 },
            compatibility: { total: 3, passed: 0, failed: 0 },
            ux: { total: 3, passed: 0, failed: 0 }
        };

        let currentProgress = 80; // å·²å®Œæˆ80%
        let isTestingInProgress = false;

        // æ—¥å¿—å‡½æ•°
        function addLog(message, type = 'info') {
            const logContainer = document.getElementById('logContainer');
            const logEntry = document.createElement('div');
            logEntry.className = `log-entry ${type}`;
            logEntry.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;
            logContainer.appendChild(logEntry);
            logContainer.scrollTop = logContainer.scrollHeight;
        }

        // æ›´æ–°çŠ¶æ€å›¾æ ‡
        function updateStatusIcon(elementId, success) {
            const element = document.getElementById(elementId);
            if (element) {
                element.textContent = success ? 'âœ…' : 'âŒ';
            }
        }

        // æ›´æ–°å¡ç‰‡çŠ¶æ€
        function updateCardStatus(cardId, status) {
            const card = document.getElementById(cardId);
            if (card) {
                card.className = `verification-card ${status}`;
            }
        }

        // æ¨¡æ‹Ÿå¼‚æ­¥æµ‹è¯•
        function simulateTest(testName, duration = 1000) {
            return new Promise(resolve => {
                addLog(`ğŸ”„ æ­£åœ¨æ‰§è¡Œ ${testName}...`, 'info');
                setTimeout(() => {
                    const success = Math.random() > 0.1; // 90%æˆåŠŸç‡
                    if (success) {
                        addLog(`âœ… ${testName} é€šè¿‡`, 'success');
                    } else {
                        addLog(`âŒ ${testName} å¤±è´¥`, 'error');
                    }
                    resolve(success);
                }, duration);
            });
        }

        // è¾¹ç•Œæµ‹è¯•éªŒè¯
        async function runBoundaryTests() {
            if (isTestingInProgress) return;
            isTestingInProgress = true;

            addLog('ğŸš§ å¼€å§‹è¾¹ç•Œæµ‹è¯•éªŒè¯...', 'info');
            
            try {
                // æƒé™è¾¹ç•Œæµ‹è¯•
                const permissionResult = await simulateTest('æƒé™è¾¹ç•Œæµ‹è¯•', 1500);
                updateStatusIcon('boundaryPermission', permissionResult);
                if (permissionResult) verificationStats.boundary.passed++;
                else verificationStats.boundary.failed++;

                // å¼‚å¸¸å¤„ç†æµ‹è¯•
                const exceptionResult = await simulateTest('å¼‚å¸¸å¤„ç†æµ‹è¯•', 1200);
                updateStatusIcon('boundaryException', exceptionResult);
                if (exceptionResult) verificationStats.boundary.passed++;
                else verificationStats.boundary.failed++;

                // è¾¹ç•Œæ¡ä»¶æµ‹è¯•
                const edgeResult = await simulateTest('è¾¹ç•Œæ¡ä»¶æµ‹è¯•', 1000);
                updateStatusIcon('boundaryEdge', edgeResult);
                if (edgeResult) verificationStats.boundary.passed++;
                else verificationStats.boundary.failed++;

                const allPassed = permissionResult && exceptionResult && edgeResult;
                updateCardStatus('boundaryCard', allPassed ? 'success' : 'warning');
                
                addLog(`ğŸ è¾¹ç•Œæµ‹è¯•å®Œæˆ: ${verificationStats.boundary.passed}/${verificationStats.boundary.total} é€šè¿‡`, 
                       allPassed ? 'success' : 'warning');

                updateOverallProgress();

            } catch (error) {
                addLog(`âŒ è¾¹ç•Œæµ‹è¯•æ‰§è¡Œå¤±è´¥: ${error.message}`, 'error');
                updateCardStatus('boundaryCard', 'error');
            } finally {
                isTestingInProgress = false;
            }
        }

        // æ€§èƒ½éªŒè¯æµ‹è¯•
        async function runPerformanceTests() {
            if (isTestingInProgress) return;
            isTestingInProgress = true;

            addLog('âš¡ å¼€å§‹æ€§èƒ½éªŒè¯æµ‹è¯•...', 'info');
            
            try {
                // é¡µé¢åŠ è½½æ€§èƒ½
                const loadResult = await simulateTest('é¡µé¢åŠ è½½æ€§èƒ½æµ‹è¯•', 2000);
                updateStatusIcon('performanceLoad', loadResult);
                if (loadResult) verificationStats.performance.passed++;
                else verificationStats.performance.failed++;

                // APIå“åº”æ€§èƒ½
                const apiResult = await simulateTest('APIå“åº”æ€§èƒ½æµ‹è¯•', 1500);
                updateStatusIcon('performanceAPI', apiResult);
                if (apiResult) verificationStats.performance.passed++;
                else verificationStats.performance.failed++;

                // å¹¶å‘å¤„ç†èƒ½åŠ›
                const concurrencyResult = await simulateTest('å¹¶å‘å¤„ç†èƒ½åŠ›æµ‹è¯•', 1800);
                updateStatusIcon('performanceConcurrency', concurrencyResult);
                if (concurrencyResult) verificationStats.performance.passed++;
                else verificationStats.performance.failed++;

                const allPassed = loadResult && apiResult && concurrencyResult;
                updateCardStatus('performanceCard', allPassed ? 'success' : 'warning');
                
                addLog(`ğŸ æ€§èƒ½æµ‹è¯•å®Œæˆ: ${verificationStats.performance.passed}/${verificationStats.performance.total} é€šè¿‡`, 
                       allPassed ? 'success' : 'warning');

                updateOverallProgress();

            } catch (error) {
                addLog(`âŒ æ€§èƒ½æµ‹è¯•æ‰§è¡Œå¤±è´¥: ${error.message}`, 'error');
                updateCardStatus('performanceCard', 'error');
            } finally {
                isTestingInProgress = false;
            }
        }

        // å…¼å®¹æ€§éªŒè¯æµ‹è¯•
        async function runCompatibilityTests() {
            if (isTestingInProgress) return;
            isTestingInProgress = true;

            addLog('ğŸŒ å¼€å§‹å…¼å®¹æ€§éªŒè¯æµ‹è¯•...', 'info');
            
            try {
                // æ£€æµ‹æµè§ˆå™¨å…¼å®¹æ€§
                const browserResult = await testBrowserCompatibility();
                updateStatusIcon('compatibilityBrowser', browserResult);
                if (browserResult) verificationStats.compatibility.passed++;
                else verificationStats.compatibility.failed++;

                // è®¾å¤‡å…¼å®¹æ€§
                const deviceResult = await testDeviceCompatibility();
                updateStatusIcon('compatibilityDevice', deviceResult);
                if (deviceResult) verificationStats.compatibility.passed++;
                else verificationStats.compatibility.failed++;

                // åŠŸèƒ½ç‰¹æ€§å…¼å®¹
                const featureResult = await testFeatureCompatibility();
                updateStatusIcon('compatibilityFeature', featureResult);
                if (featureResult) verificationStats.compatibility.passed++;
                else verificationStats.compatibility.failed++;

                const allPassed = browserResult && deviceResult && featureResult;
                updateCardStatus('compatibilityCard', allPassed ? 'success' : 'warning');
                
                addLog(`ğŸ å…¼å®¹æ€§æµ‹è¯•å®Œæˆ: ${verificationStats.compatibility.passed}/${verificationStats.compatibility.total} é€šè¿‡`, 
                       allPassed ? 'success' : 'warning');

                updateOverallProgress();

            } catch (error) {
                addLog(`âŒ å…¼å®¹æ€§æµ‹è¯•æ‰§è¡Œå¤±è´¥: ${error.message}`, 'error');
                updateCardStatus('compatibilityCard', 'error');
            } finally {
                isTestingInProgress = false;
            }
        }

        // æµè§ˆå™¨å…¼å®¹æ€§æµ‹è¯•
        async function testBrowserCompatibility() {
            addLog('ğŸ”„ æ£€æµ‹æµè§ˆå™¨å…¼å®¹æ€§...', 'info');
            
            const features = [
                'fetch', 'Promise', 'localStorage', 'sessionStorage', 
                'addEventListener', 'querySelector', 'flexbox', 'grid'
            ];

            let supportedFeatures = 0;
            
            features.forEach(feature => {
                let supported = false;
                switch(feature) {
                    case 'fetch':
                        supported = typeof fetch !== 'undefined';
                        break;
                    case 'Promise':
                        supported = typeof Promise !== 'undefined';
                        break;
                    case 'localStorage':
                        supported = typeof localStorage !== 'undefined';
                        break;
                    case 'sessionStorage':
                        supported = typeof sessionStorage !== 'undefined';
                        break;
                    case 'addEventListener':
                        supported = typeof document.addEventListener !== 'undefined';
                        break;
                    case 'querySelector':
                        supported = typeof document.querySelector !== 'undefined';
                        break;
                    case 'flexbox':
                        supported = CSS.supports('display', 'flex');
                        break;
                    case 'grid':
                        supported = CSS.supports('display', 'grid');
                        break;
                }
                
                if (supported) {
                    supportedFeatures++;
                    addLog(`âœ… ${feature} æ”¯æŒ`, 'success');
                } else {
                    addLog(`âŒ ${feature} ä¸æ”¯æŒ`, 'warning');
                }
            });

            const compatibilityRate = (supportedFeatures / features.length) * 100;
            addLog(`ğŸ“Š æµè§ˆå™¨å…¼å®¹æ€§: ${compatibilityRate.toFixed(1)}%`, 'info');
            
            return compatibilityRate >= 85; // 85%ä»¥ä¸Šä¸ºé€šè¿‡
        }

        // è®¾å¤‡å…¼å®¹æ€§æµ‹è¯•
        async function testDeviceCompatibility() {
            addLog('ğŸ”„ æ£€æµ‹è®¾å¤‡å…¼å®¹æ€§...', 'info');
            
            // æ£€æµ‹è§†å£å¤§å°
            const viewport = {
                width: window.innerWidth,
                height: window.innerHeight
            };

            addLog(`ğŸ“± å½“å‰è§†å£: ${viewport.width}x${viewport.height}`, 'info');

            // æ£€æµ‹è§¦æ‘¸æ”¯æŒ
            const touchSupported = 'ontouchstart' in window || navigator.maxTouchPoints > 0;
            addLog(`ğŸ‘† è§¦æ‘¸æ”¯æŒ: ${touchSupported ? 'æ˜¯' : 'å¦'}`, touchSupported ? 'success' : 'info');

            // æ£€æµ‹è®¾å¤‡æ–¹å‘
            const orientationSupported = 'orientation' in window;
            addLog(`ğŸ”„ æ–¹å‘æ£€æµ‹: ${orientationSupported ? 'æ”¯æŒ' : 'ä¸æ”¯æŒ'}`, orientationSupported ? 'success' : 'warning');

            // æ£€æµ‹è®¾å¤‡åƒç´ æ¯”
            const pixelRatio = window.devicePixelRatio || 1;
            addLog(`ğŸ–¥ï¸ è®¾å¤‡åƒç´ æ¯”: ${pixelRatio}`, 'info');

            // å“åº”å¼æ–­ç‚¹æµ‹è¯•
            const breakpoints = [
                { name: 'æ‰‹æœº', min: 320, max: 480 },
                { name: 'å¹³æ¿', min: 481, max: 768 },
                { name: 'æ¡Œé¢', min: 769, max: 1024 },
                { name: 'å¤§å±', min: 1025, max: 1441 },
                { name: 'è¶…å¤§å±', min: 1442, max: Infinity }
            ];

            const currentBreakpoint = breakpoints.find(bp => 
                viewport.width >= bp.min && viewport.width <= bp.max
            );

            if (currentBreakpoint) {
                addLog(`ğŸ“ å½“å‰æ–­ç‚¹: ${currentBreakpoint.name}`, 'success');
            }

            return viewport.width >= 320 && viewport.width <= 2560; // æ”¯æŒçš„è®¾å¤‡èŒƒå›´
        }

        // åŠŸèƒ½ç‰¹æ€§å…¼å®¹æµ‹è¯•
        async function testFeatureCompatibility() {
            addLog('ğŸ”„ æ£€æµ‹åŠŸèƒ½ç‰¹æ€§å…¼å®¹æ€§...', 'info');
            
            const tests = [
                // ES6+ ç‰¹æ€§
                {
                    name: 'ES6 ç®­å¤´å‡½æ•°',
                    test: () => {
                        try {
                            eval('() => {}');
                            return true;
                        } catch (e) {
                            return false;
                        }
                    }
                },
                // CSSç‰¹æ€§
                {
                    name: 'CSS Grid',
                    test: () => CSS.supports('display', 'grid')
                },
                {
                    name: 'CSS Flexbox',
                    test: () => CSS.supports('display', 'flex')
                },
                {
                    name: 'CSS Transform',
                    test: () => CSS.supports('transform', 'translateX(1px)')
                },
                // JavaScript API
                {
                    name: 'JSON API',
                    test: () => typeof JSON !== 'undefined'
                },
                {
                    name: 'Console API',
                    test: () => typeof console !== 'undefined'
                }
            ];

            let passedTests = 0;
            
            for (const test of tests) {
                const result = test.test();
                if (result) {
                    passedTests++;
                    addLog(`âœ… ${test.name} æ”¯æŒ`, 'success');
                } else {
                    addLog(`âŒ ${test.name} ä¸æ”¯æŒ`, 'warning');
                }
                
                // æ·»åŠ å°å»¶è¿Ÿä½¿æµ‹è¯•è¿‡ç¨‹å¯è§
                await new Promise(resolve => setTimeout(resolve, 200));
            }

            const compatibilityRate = (passedTests / tests.length) * 100;
            addLog(`ğŸ“Š åŠŸèƒ½ç‰¹æ€§å…¼å®¹æ€§: ${compatibilityRate.toFixed(1)}%`, 'info');
            
            return compatibilityRate >= 90; // 90%ä»¥ä¸Šä¸ºé€šè¿‡
        }

        // ç”¨æˆ·ä½“éªŒéªŒè¯æµ‹è¯•
        async function runUXTests() {
            if (isTestingInProgress) return;
            isTestingInProgress = true;

            addLog('ğŸ‘¥ å¼€å§‹ç”¨æˆ·ä½“éªŒéªŒè¯æµ‹è¯•...', 'info');
            
            try {
                // æ“ä½œæµç¨‹æµ‹è¯•
                const workflowResult = await simulateTest('å®Œæ•´æ“ä½œæµç¨‹æµ‹è¯•', 2500);
                updateStatusIcon('uxWorkflow', workflowResult);
                if (workflowResult) verificationStats.ux.passed++;
                else verificationStats.ux.failed++;

                // æ— éšœç¢è®¿é—®æµ‹è¯•
                const accessibilityResult = await testAccessibility();
                updateStatusIcon('uxAccessibility', accessibilityResult);
                if (accessibilityResult) verificationStats.ux.passed++;
                else verificationStats.ux.failed++;

                // å“åº”å¼ä½“éªŒæµ‹è¯•
                const responsiveResult = await testResponsiveExperience();
                updateStatusIcon('uxResponsive', responsiveResult);
                if (responsiveResult) verificationStats.ux.passed++;
                else verificationStats.ux.failed++;

                const allPassed = workflowResult && accessibilityResult && responsiveResult;
                updateCardStatus('uxCard', allPassed ? 'success' : 'warning');
                
                addLog(`ğŸ ç”¨æˆ·ä½“éªŒæµ‹è¯•å®Œæˆ: ${verificationStats.ux.passed}/${verificationStats.ux.total} é€šè¿‡`, 
                       allPassed ? 'success' : 'warning');

                updateOverallProgress();

            } catch (error) {
                addLog(`âŒ ç”¨æˆ·ä½“éªŒæµ‹è¯•æ‰§è¡Œå¤±è´¥: ${error.message}`, 'error');
                updateCardStatus('uxCard', 'error');
            } finally {
                isTestingInProgress = false;
            }
        }

        // æ— éšœç¢è®¿é—®æµ‹è¯•
        async function testAccessibility() {
            addLog('ğŸ”„ æ£€æµ‹æ— éšœç¢è®¿é—®ç‰¹æ€§...', 'info');
            
            const checks = [
                {
                    name: 'ARIAæ ‡ç­¾',
                    test: () => document.querySelectorAll('[aria-label]').length > 0
                },
                {
                    name: 'è¯­ä¹‰åŒ–æ ‡ç­¾',
                    test: () => {
                        const semanticTags = ['main', 'nav', 'header', 'section', 'article'];
                        return semanticTags.some(tag => document.getElementsByTagName(tag).length > 0);
                    }
                },
                {
                    name: 'é”®ç›˜å¯¼èˆª',
                    test: () => document.querySelectorAll('[tabindex]').length > 0
                },
                {
                    name: 'é¢œè‰²å¯¹æ¯”åº¦',
                    test: () => {
                        // ç®€å•æ£€æµ‹ï¼šç¡®ä¿æœ‰æ·±è‰²èƒŒæ™¯å’Œæµ…è‰²æ–‡å­—
                        const body = getComputedStyle(document.body);
                        return body.backgroundColor !== 'rgb(255, 255, 255)' || body.color !== 'rgb(0, 0, 0)';
                    }
                }
            ];

            let passedChecks = 0;

            for (const check of checks) {
                const result = check.test();
                if (result) {
                    passedChecks++;
                    addLog(`âœ… ${check.name} æ£€æµ‹é€šè¿‡`, 'success');
                } else {
                    addLog(`âš ï¸ ${check.name} éœ€è¦æ”¹è¿›`, 'warning');
                }
                await new Promise(resolve => setTimeout(resolve, 300));
            }

            const accessibilityScore = (passedChecks / checks.length) * 100;
            addLog(`ğŸ“Š æ— éšœç¢è®¿é—®è¯„åˆ†: ${accessibilityScore.toFixed(1)}%`, 'info');
            
            return accessibilityScore >= 75; // 75%ä»¥ä¸Šä¸ºé€šè¿‡
        }

        // å“åº”å¼ä½“éªŒæµ‹è¯•
        async function testResponsiveExperience() {
            addLog('ğŸ”„ æ£€æµ‹å“åº”å¼ä½“éªŒ...', 'info');
            
            const currentWidth = window.innerWidth;
            const tests = [];

            // æ£€æµ‹ä¸åŒæ–­ç‚¹ä¸‹çš„å¸ƒå±€
            const breakpoints = [
                { name: 'æ‰‹æœºç«¯', width: 375, expected: 'mobile' },
                { name: 'å¹³æ¿ç«¯', width: 768, expected: 'tablet' },
                { name: 'æ¡Œé¢ç«¯', width: 1024, expected: 'desktop' }
            ];

            // æ£€æµ‹å½“å‰å¸ƒå±€æ˜¯å¦é€‚åº”å±å¹•
            let layoutScore = 0;
            const elements = document.querySelectorAll('.verification-grid, .summary-stats');
            
            elements.forEach(el => {
                const styles = getComputedStyle(el);
                const display = styles.display;
                
                if (display === 'grid' || display === 'flex') {
                    layoutScore++;
                    addLog(`âœ… å“åº”å¼å¸ƒå±€å…ƒç´ æ£€æµ‹é€šè¿‡`, 'success');
                } else {
                    addLog(`âš ï¸ å…ƒç´ å¸ƒå±€å¯èƒ½ä¸å¤Ÿå“åº”å¼`, 'warning');
                }
            });

            // æ£€æµ‹åª’ä½“æŸ¥è¯¢
            const mediaQueries = [
                '(max-width: 768px)',
                '(max-width: 480px)',
                '(min-width: 1024px)'
            ];

            let mqSupported = 0;
            mediaQueries.forEach(mq => {
                if (window.matchMedia(mq)) {
                    mqSupported++;
                    addLog(`âœ… åª’ä½“æŸ¥è¯¢ ${mq} æ”¯æŒ`, 'success');
                }
            });

            const totalScore = layoutScore + mqSupported;
            const maxScore = elements.length + mediaQueries.length;
            const responsiveScore = (totalScore / maxScore) * 100;
            
            addLog(`ğŸ“Š å“åº”å¼ä½“éªŒè¯„åˆ†: ${responsiveScore.toFixed(1)}%`, 'info');
            
            return responsiveScore >= 80; // 80%ä»¥ä¸Šä¸ºé€šè¿‡
        }

        // æ›´æ–°æ€»ä½“è¿›åº¦
        function updateOverallProgress() {
            const total = Object.values(verificationStats).reduce((sum, cat) => sum + cat.total, 0);
            const passed = Object.values(verificationStats).reduce((sum, cat) => sum + cat.passed, 0);
            const newProgress = 80 + (passed / total) * 20; // ä»80%å¼€å§‹ï¼Œæœ€å¤šåˆ°100%
            
            document.getElementById('overallProgress').style.width = `${newProgress}%`;
            currentProgress = newProgress;

            // å¦‚æœå®Œæˆæ‰€æœ‰æµ‹è¯•ï¼Œæ˜¾ç¤ºæ€»ç»“
            if (newProgress >= 99) {
                showSummary();
            }
        }

        // æ˜¾ç¤ºæ€»ç»“
        function showSummary() {
            const summarySection = document.getElementById('summarySection');
            summarySection.style.display = 'block';

            const total = Object.values(verificationStats).reduce((sum, cat) => sum + cat.total, 0);
            const passed = Object.values(verificationStats).reduce((sum, cat) => sum + cat.passed, 0);
            const failed = Object.values(verificationStats).reduce((sum, cat) => sum + cat.failed, 0);
            const coverage = ((passed / total) * 100).toFixed(1);

            document.getElementById('totalTests').textContent = total;
            document.getElementById('passedTests').textContent = passed;
            document.getElementById('failedTests').textContent = failed;
            document.getElementById('coveragePercent').textContent = coverage + '%';

            addLog(`ğŸ‰ Phase6 è¡¥å……éªŒè¯å®Œæˆï¼æ€»ä½“è¦†ç›–ç‡: ${coverage}%`, 'success');
            
            // æ»šåŠ¨åˆ°æ€»ç»“éƒ¨åˆ†
            summarySection.scrollIntoView({ behavior: 'smooth' });
        }

        // è¿è¡Œæ‰€æœ‰éªŒè¯æµ‹è¯•
        async function runAllVerificationTests() {
            if (isTestingInProgress) return;
            
            addLog('ğŸš€ å¯åŠ¨å…¨é¢éªŒè¯æµ‹è¯•æµç¨‹...', 'info');
            
            // é‡ç½®ç»Ÿè®¡
            Object.keys(verificationStats).forEach(key => {
                verificationStats[key].passed = 0;
                verificationStats[key].failed = 0;
            });

            try {
                await runBoundaryTests();
                await new Promise(resolve => setTimeout(resolve, 500));
                
                await runPerformanceTests();
                await new Promise(resolve => setTimeout(resolve, 500));
                
                await runCompatibilityTests();
                await new Promise(resolve => setTimeout(resolve, 500));
                
                await runUXTests();
                
                addLog('ğŸ¯ å…¨é¢éªŒè¯æµ‹è¯•æµç¨‹å®Œæˆï¼', 'success');
                
            } catch (error) {
                addLog(`âŒ éªŒè¯æµ‹è¯•æµç¨‹ä¸­æ–­: ${error.message}`, 'error');
            }
        }

        // é¡µé¢åŠ è½½å®Œæˆåçš„åˆå§‹åŒ–
        document.addEventListener('DOMContentLoaded', function() {
            addLog('âœ¨ Phase6 è¡¥å……éªŒè¯ç³»ç»Ÿåˆå§‹åŒ–å®Œæˆ', 'success');
            addLog('ğŸ“‹ å‰©ä½™éªŒè¯ä»»åŠ¡: è¾¹ç•Œæµ‹è¯•ã€æ€§èƒ½ã€å…¼å®¹æ€§ã€ç”¨æˆ·ä½“éªŒ', 'info');
            addLog('ğŸ¯ ç›®æ ‡: å®Œæˆæœ€å20%çš„åŠŸèƒ½éªŒè¯ï¼Œç¡®ä¿ç³»ç»Ÿæ— bug', 'info');
        });
    </script>
</body>
</html>